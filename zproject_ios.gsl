#   Generate iOS build system files
#
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/zeromq/gsl for details.
#
#   Copyright (c) the Contributors as noted in the AUTHORS file.
#   This file is part of zproject.
#
#   This Source Code Form is subject to the terms of the Mozilla Public
#   License, v. 2.0. If a copy of the MPL was not distributed with this
#   file, You can obtain one at http://mozilla.org/MPL/2.0/.

register_target ("ios", "Native library for iOS")

function target_ios

.macro target_ios
.directory.create ("builds/ios")
.
.output "builds/ios/README.md"
# iOS Build

## Prerequisites

The build script require to be run on MacOs with XCode and the developer SDK installed.

This project is tested against SDK 15.5.

If you want to specify another version you need to set the environment variable below:

    export SDK_VERSION=15.5

You can list all the versions of the SDK installed on your Mac using the command below:

    xcodebuild -showsdks

## Build

In the ios directory, run:
    \./build.sh [ iPhoneOS armv7 | iPhoneOS armv7s | iPhoneOS arm64 | iPhoneSimulator i386 | iPhoneSimulator x86_64 ]

Note that certain target architectures may or may not be available depending on your target SDK Version. For example, iOS 10 is the maximum deployment target for 32-bit targets.

[This website](https://docs.elementscompiler.com/Platforms/Cocoa/CpuArchitectures/) can help you choose which architecture you need to target depending on your SDK version.
.close
.
.output "builds/ios/build.sh"
#!/usr/bin/env bash
$(project.GENERATED_WARNING_HEADER:)

set -e

# Set this to enable verbose profiling
[ -n "${CI_TIME-}" ] || CI_TIME=""
case "$CI_TIME" in
    [Yy][Ee][Ss]|[Oo][Nn]|[Tt][Rr][Uu][Ee])
        CI_TIME="time -p " ;;
    [Nn][Oo]|[Oo][Ff][Ff]|[Ff][Aa][Ll][Ss][Ee])
        CI_TIME="" ;;
esac

# Set this to enable verbose tracing
[ -n "${CI_TRACE-}" ] || CI_TRACE="no"
case "$CI_TRACE" in
    [Nn][Oo]|[Oo][Ff][Ff]|[Ff][Aa][Ll][Ss][Ee])
        set +x ;;
    [Yy][Ee][Ss]|[Oo][Nn]|[Tt][Rr][Uu][Ee])
        set -x ;;
esac

function usage {
    echo "Usage ./build.sh [ iPhoneOS armv7 | iPhoneOS armv7s | iPhoneOS arm64 | iPhoneSimulator i386 | iPhoneSimulator x86_64 ]"
}

PLATFORM=$1
if [ -z "$PLATFORM" ]; then
    usage
    exit 1
fi

TARGET=$2
if [ -z "$TARGET" ]; then
    usage
    exit 1
fi

if [[ $TARGET == "x86_64" ]]; then
    HOST="i386"
elif [[ $TARGET == "arm64" ]]; then
    HOST="arm"
else
    HOST=$TARGET
fi

export SDK_VERSION=${SDK_VERSION:-"15.5"}

PLATFORM_PATH="/Applications/Xcode.app/Contents/Developer/Platforms"
TOOLCHAIN_PATH="/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin"
SYSROOT="$PLATFORM_PATH/$PLATFORM.platform/Developer/SDKs/$PLATFORM$SDK_VERSION.sdk"
OUTPUT_DIR="/tmp/ios_build/$PLATFORM/$TARGET"
SDK="iphoneos"

export CC="\$(xcrun -sdk $SDK -find clang)"
export CPP="$CC -E"
export AR="\$(xcrun -sdk $SDK -find ar)"
export RANLIB="\$(xcrun -sdk $SDK -find ranlib)"
export CFLAGS="-arch $TARGET -isysroot $SYSROOT -miphoneos-version-min=$SDK_VERSION -fembed-bitcode"
export CPPFLAGS="-arch $TARGET -isysroot $SYSROOT -miphoneos-version-min=$SDK_VERSION -fembed-bitcode"
export LDFLAGS="-arch $TARGET -isysroot $SYSROOT"
export PKG_CONFIG_PATH="$OUTPUT_DIR/lib/pkgconfig"

cd ../../
mkdir -p $OUTPUT_DIR
$CI_TIME ./autogen.sh
$CI_TIME ./configure --prefix=$OUTPUT_DIR --host=$HOST-apple-darwin --disable-shared --without-libcurl --without-liblz4
$CI_TIME make
$CI_TIME make install

echo "$PLATFORM $TARGET build successful"
$(project.GENERATED_WARNING_HEADER:)
.close
.chmod_x ("builds/ios/build.sh")
.#
.output "builds/ios/ci_build.sh"
#!/usr/bin/env bash
$(project.GENERATED_WARNING_HEADER:)

if [[ \$(uname | tr '[:upper:]' '[:lower:]') != "darwin" ]]; then
    echo "Unsupported platform"
    exit 1
fi

\./build.sh "iPhoneOS" "arm64"
git clean -fdx ../../..
\./build.sh "iPhoneSimulator" "x86_64"

$(project.GENERATED_WARNING_HEADER:)
.close
.chmod_x ("builds/ios/ci_build.sh")
.
.output "builds/ios/$(project.prefix:pascal)-Bridging-Header.h"
/*
$(project.GENERATED_WARNING_HEADER:)
*/

#ifndef __$(project.prefix:upper)_BRIDGING_HEADER_H__
#define __$(project.prefix:upper)_BRIDGING_HEADER_H__

#include "$(project.prefix:c).h"
#include "swift_bindings_utils.h"

#endif//__$(project.prefix:upper)_BRIDGING_HEADER_H__

.close
.endmacro

function resolve_container (container)
    #   Type of container shown to Swift
    my.container.swift_type = ""

    if my.container.type = "nothing"
        my.container.swift_type = "void"

    elsif my.container.type = "sockish"
        my.container.swift_type = "Int"

    elsif my.container.type = "boolean"
        my.container.swift_type = "Bool"

    elsif my.container.type = "size"
        my.container.swift_type = "Int"

    elsif my.container.type = "integer"
        my.container.swift_type = "Int32"

    elsif my.container.type = "number"
        if my.container.size ?= "1"
            my.container.swift_type = "UInt8"
        elsif my.container.size = 2
            my.container.swift_type = "UInt16"
        elsif my.container.size = 4
            my.container.swift_type = "UInt32"
        elsif my.container.size = 8
            my.container.swift_type = "UInt64"
        endif

    elsif my.container.type = "real"
        if my.container.size ?= "4"
            my.container.swift_type = "Float"
        elsif my.container.size ?= "8"
            my.container.swift_type = "Double"
        endif

    elsif my.container.type = "string"
        if my.container.by_reference
            return 1        #   Skip methods that do this
        endif
        my.container.swift_type = "String"

    elsif my.container.type = "format"
        my.container.swift_type = "String"

    elsif count (project.class, class.c_name = my.container.type) \
    |     count (project->dependencies.class, class.c_name = my.container.type)
        my.container.swift_type = "$(my.container.type:pascal)"

    else
        abort "Unhandled type '$(my.container.type:)' in $(class.c_name)"
    endif

    return 0            #   Seems to be OK
endfunction

function resolve_method (method)
    my.method.okay = 1

    for my.method.argument
        if resolve_container (argument) = 1
            my.method.okay = 0
            #echo "Skipping $(class.name).$(my.method.name) - can't deal with argument type $(argument.type)"
            last
        endif
    endfor


    for my.method.return
        if resolve_container (return)
            my.method.okay = 0
            #echo "Skipping $(class.name).$(my.method.name) - can't deal with return type $(return.type:)"
        endif
    endfor
endfunction

function resolve_class (class)
    my.class.okay = 1
        for constructor
            resolve_method (constructor)
        endfor
        for destructor
            resolve_method (destructor)
        endfor
        for method
            resolve_method (method)
        endfor
endfunction

.macro generate_class (class)
.   directory.create ("$(topdir)/$(project.prefix:c)-swift/src")
.   output "$(topdir)/$(project.prefix:c)-swift/src/$(my.class.name:pascal).swift"
/*
$(project.GENERATED_WARNING_HEADER:)
*/

public class $(my.class.name:pascal) {
    let ptr: OpaquePointer?

    private init(_ ptr: OpaquePointer?) {
        self.ptr = ptr!
    }
.   for constructor where okay

    /*
      $(description:no,block)
    */
    public static func $(name:camel)(\
.       arg_count = count (argument)
.       for argument
$(name:camel): $(swift_type:no)\
.           if index () <> arg_count
, \
.           endif
.       endfor
) -> $(my.class.name:pascal) {
        return $(my.class.name:pascal)($(class.name:c)_$(constructor.name:c)(\
.       for argument
$(name:camel)\
.           if index () <> arg_count
, \
.           endif
.       endfor
))
    }
.   endfor
.   for destructor

    /*
      $(description:no,block)
    */
    deinit {
        let selfPtr: UnsafeMutablePointer<OpaquePointer?>? = UnsafeMutablePointer(ptr)
        $(my.class.name:c)_destroy(selfPtr)
        selfPtr?.deallocate()
    }
.   endfor
.   for method where okay

    /*
      $(description:no,block)
    */
.       if singleton = 1
.           my.prefix = "public static"
.       else
.           my.prefix = "public"
.       endif
.       if ->return.type = "nothing"
.           my.return_type = ""
.       else
.           my.return_type = " -> $(->return.swift_type:no)"
.       endif
    $(my.prefix) func $(method.name:lower,camel)(\
.       arg_count = count (argument)
.       for argument
$(name:camel): $(swift_type:no)\
.           if index () <> arg_count
, \
.           endif
.       endfor
)$(my.return_type:no) {
.       if ->return.type = "nothing"
.           my.return = ""
.       elsif ->return.type = "string"
.           if ->return.fresh = 1
.               my.return = "let ret: UnsafeMutablePointer<CChar>? = "
.           else
.               my.return = "let ret: UnsafePointer<CChar>? = "
.           endif
.       elsif ->return.swift_type = "UInt32"
.           my.return = "let ret: UInt = "
.       else
.           my.return = "let ret: $(->return.swift_type:no) = "
.       endif
.       if singleton = 1
.           my.self_arg = ""
.       else
.           my.self_arg = "ptr"
.       endif
        $(my.return:no)$(class.name:c)_$(method.name:c)($(my.self_arg)\
.       for argument
.           if index () <> 1 | method.singleton <> 1
, \
.           endif
.           if swift_type = "UInt32"
UInt($(name:camel))\
.           else
$(name:camel)\
.           endif
.       endfor
)
.       if ->return.type = "string"
        let str = String(validatingUTF8: ret!)!
        ret?.deallocate()
        return str
.       elsif ->return.swift_type = "UInt32"
        return UInt32(ret)
.       elsif ->return.type <> "nothing"
        return ret
.       endif
    }
.   endfor
}
.endmacro

    project.topdir = "bindings/swift"
    directory.create (topdir)

    for project.class
        resolve_class (class)
        if class.okay
            generate_class (class)
        endif
    endfor
endfunction
