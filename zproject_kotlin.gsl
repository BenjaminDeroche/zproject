#   Generate Kotlin JNA bindings.
#
#   Due to the limitations of Java and JNI, new bindings were born using
#   Kotlin and JNA.
#
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/zeromq/gsl for details.
#
#   Copyright (c) the Contributors as noted in the AUTHORS file.
#   This file is part of zproject.
#
#   This Source Code Form is subject to the terms of the Mozilla Public
#   License, v. 2.0. If a copy of the MPL was not distributed with this
#   file, You can obtain one at http://mozilla.org/MPL/2.0/.

register_target ("kotlin", "Next gen Android/JVM binding")

#   Target provides name space isolation for its functions
function target_kotlin

gsl from "zproject_kotlin_lib.gsl"

.macro generate_wrapper
.output "$(topdir)/build.gradle.kts"
/*
$(project.GENERATED_WARNING_HEADER:)
*/

plugins {
    alias(libs.plugins.nexusPublish)
    alias(libs.plugins.androidLibrary).apply(false)
    alias(libs.plugins.kotlinMultiplatform).apply(false)
}

allprojects {
    group = "$(project.namespace)"

    if (project.hasProperty("isRelease")) {
        version = "$(->version.major).$(->version.minor).$(->version.patch)"
    } else {
        version = "$(->version.major).$(->version.minor).$(->version.patch)-SNAPSHOT"
    }
}

nexusPublishing {
    // Configure maven central repository
    // https://github.com/gradle-nexus/publish-plugin#publishing-to-maven-central-via-sonatype-ossrh
    repositories {
        sonatype {  //only for users registered in Sonatype after 24 Feb 2021
            nexusUrl.set(uri("https://s01.oss.sonatype.org/service/local/"))
            snapshotRepositoryUrl.set(uri("https://s01.oss.sonatype.org/content/repositories/snapshots/"))
        }
    }
}

//project.gradle.taskGraph.whenReady { TaskExecutionGraph taskGraph ->
//    if (System.getenv("GRADLE_VERBOSE") == "1") {
//        Task execTask = taskGraph.allTasks.last()
//        println("Task plan for '${execTask.project.name}:${execTask.name}'")
//        taskGraph.allTasks.eachWithIndex { Task task, int n ->
//            println "${String.format("%3s", n + 1)} - '${task.project.name}:${task.name}'"
//        }
//    }
//}

.
.output "$(topdir)/$(project.prefix:c)/build.gradle.kts"
/*
$(project.GENERATED_WARNING_HEADER:)
*/

import org.jetbrains.kotlin.gradle.ExperimentalKotlinGradlePluginApi
import org.jetbrains.kotlin.gradle.dsl.JvmTarget

plugins {
    alias(libs.plugins.kotlinMultiplatform)
    alias(libs.plugins.androidLibrary)
    `maven-publish`
    signing
}

val dependenciesVersion =
    if (project.hasProperty("isRelease"))
        "latest.release"
    else
        "latest.integration"

kotlin {
    targetHierarchy.default()

    jvm {
    }
    androidTarget {
        publishLibraryVariants("release")
        @OptIn(ExperimentalKotlinGradlePluginApi::class)
        compilerOptions {
            jvmTarget.set(JvmTarget.JVM_1_8)
        }
    }

    sourceSets {
        commonMain {
            dependencies {
.   for project.use
.       if count (project->dependencies.class, class.project = use.project) > 0
                implementation("org.zeromq.$(use.project):$(use.project):$dependenciesVersion")
.       endif
.   endfor
            }
        }
        commonTest {
            dependencies {
                implementation(libs.kotlinTest)
            }
        }
        jvmMain {
            resources.srcDir("nativeLibs")
            dependencies {
                implementation(libs.jna)
            }
        }
        jvmTest {
            dependencies {
            }
        }
        androidMain {
            dependencies {
                // TODO: Android should use the @aar artifact type
                api(libs.jna)// {
//                artifact {
//                    type = "aar"
//                }
//            }
            }
        }
        androidUnitTest {
            dependencies {
            }
        }
    }
}

android {
    namespace = "org.zeromq.library"
    compileSdk = 34
    defaultConfig {
        minSdk = 21
    }
}

publishing {
    publications.withType<MavenPublication> {
        // Stub javadoc.jar artifact
        artifact(tasks.register("${name}JavadocJar", Jar::class) {
            archiveClassifier.set("javadoc")
            archiveAppendix.set(this@withType.name)
        })

        // Provide artifacts information required for publication
        pom {
            name.set("$(project.name:c)")
            description.set("$(project.description:no)")
            url.set("$(project.url)")

            licenses {
                license {
                    name.set("Mozilla Public License Version 2.0")
                    url.set("https://www.mozilla.org/en-US/MPL/2.0/")
                }
            }
            scm {
                connection.set("$(project.url).git")
                developerConnection.set("$(project.url).git")
                url.set("$(project.url)")
            }
        }
    }
}

signing {
//    if (project.hasProperty("signing.gnupg.keyName")) {
//        useGpgCmd()
//        sign(publishing.publications)
//    }
}

.
.output "$(topdir)/README.md"
# $(project.prefix)

TODO!
.
.directory.create ("$(topdir)/gradle")
.output "$(topdir)/gradle/libs.versions.toml"
$(project.GENERATED_WARNING_HEADER:)

[versions]
agp = "8.5.2"
kotlin = "2.0.20"
publish = "2.0.0"
jna = "5.15.0"

[libraries]
kotlinTest = { group = "org.jetbrains.kotlin", name = "kotlin-test", version.ref = "kotlin" }
jna = { group = "net.java.dev.jna", name = "jna", version.ref = "jna" }

[plugins]
androidLibrary = { id = "com.android.library", version.ref = "agp" }
kotlinMultiplatform = { id = "org.jetbrains.kotlin.multiplatform", version.ref = "kotlin" }
nexusPublish = { id = "io.github.gradle-nexus.publish-plugin", version.ref = "publish" }

.
.output "$(topdir)/settings.gradle.kts"
/*
$(project.GENERATED_WARNING_HEADER:)
*/

pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

dependencyResolutionManagement {
    repositories {
        google()
        mavenCentral()
        mavenLocal()
    }
}

rootProject.name = "$(project.prefix)"
include(":$(project.prefix)")

.
.output "$(topdir)/.gitignore"
*.iml
\.gradle
\.idea
\.DS_Store
build
captures
\.externalNativeBuild
\.cxx
local.properties
xcuserdata
\.kotlin
.
.directory.create ("$(topdir)/$(project.prefix:c)/android")
.terminator="\n"
.output "$(topdir)/$(project.prefix:c)/android/build.sh"
#!/bin/bash
$(project.GENERATED_WARNING_HEADER:)
#   Build JNI interface for Android
#
#   Requires these environment variables be set, e.g.:
#
#     NDK_VERSION=$(project.android_ndk_version)
#
#   Exit if any step fails
set -e

# Use directory of current script as the working directory
cd "\$( dirname "${BASH_SOURCE[0]}" )"
PROJECT_ROOT="\$(cd ../../../.. && pwd)"

# Configuration
export NDK_VERSION="${NDK_VERSION:-$(project.android_ndk_version)}"
export ANDROID_NDK_ROOT="${ANDROID_NDK_ROOT:-/tmp/${NDK_VERSION}}"
export MIN_SDK_VERSION=${MIN_SDK_VERSION:-$(project.android_min_sdk_version)}
export ANDROID_BUILD_DIR="${ANDROID_BUILD_DIR:-/tmp/android_build}"
export ANDROID_DEPENDENCIES_DIR="${ANDROID_DEPENDENCIES_DIR:-/tmp/tmp-deps}"

export CI_CONFIG_QUIET="${CI_CONFIG_QUIET:-yes}"
export CI_TIME="${CI_TIME:-}"
export CI_TRACE="${CI_TRACE:-no}"

########################################################################
# Utilities
########################################################################
# Get access to android_build functions and variables
# Perform some sanity checks and calculate some variables.
source "${PROJECT_ROOT}/builds/android/android_build_helper.sh"

function usage {
    echo "$(PROJECT.NAME) - Usage:"
    echo "  export XXX=xxx"
    echo "  ./build.sh [ arm | arm64 | x86 | x86_64 ]"
    echo ""
    echo "See this file (configuration & tuning options) for details"
    echo "on variables XXX and their values xxx"
    exit 1
}

########################################################################
# Sanity checks
########################################################################
BUILD_ARCH="$1"
[ -z "${BUILD_ARCH}" ] && usage

# Export android build's environment variables for cmake
android_build_set_env "${BUILD_ARCH}"
android_download_ndk

case "$CI_TIME" in
    [Yy][Ee][Ss]|[Oo][Nn]|[Tt][Rr][Uu][Ee])
        CI_TIME="time -p " ;;
    [Nn][Oo]|[Oo][Ff][Ff]|[Ff][Aa][Ll][Ss][Ee])
        CI_TIME="" ;;
esac

case "$CI_TRACE" in
    [Nn][Oo]|[Oo][Ff][Ff]|[Ff][Aa][Ll][Ss][Ee])
        set +x ;;
    [Yy][Ee][Ss]|[Oo][Nn]|[Tt][Rr][Uu][Ee])
        set -x
        MAKE_OPTIONS=VERBOSE=1
        GRADLE_VERBOSE=1
        ;;
esac

########################################################################
# Compilation
########################################################################
GRADLEW_OPTS=()
GRADLEW_OPTS+=("-PbuildPrefix=$BUILD_PREFIX")
GRADLEW_OPTS+=("--info")

#   Build any dependent libraries
#   Use a default value assuming that dependent libraries sit alongside this one
.for project.use
.   if count (project->dependencies.class, class.project = use.project) > 0
( cd ${$(USE.PROJECT)_ROOT}/bindings/jna/$(use.prefix)/android; ./build.sh $BUILD_ARCH )
.   endif
.endfor

#   Ensure we've built dependencies for Android
android_build_trace "Building Android native libraries"
( cd ../../../../builds/android && ./build.sh $BUILD_ARCH )

#   Copy native libraries into bindings/jna/$(project.prefix:c)/nativeLibs/lib/$TOOLCHAIN_ABI
ABI_DIR="${PROJECT_ROOT}/bindings/jna/$(project.prefix:c)/src/androidMain/jniLibs/$TOOLCHAIN_ABI"
mkdir -p ${ABI_DIR}
cp $ANDROID_BUILD_PREFIX/lib/*.so ${ABI_DIR}
cp ${ANDROID_STL_ROOT}/${ANDROID_STL} ${ABI_DIR}

android_build_trace "Android JNI build successful"

$(project.GENERATED_WARNING_HEADER:)
.chmod_x ("$(topdir)/$(project.prefix:c)/android/build.sh")
.
.output "$(topdir)/ci_build.sh"
#!/usr/bin/env bash
$(project.GENERATED_WARNING_HEADER:)
#
#   Exit if any step fails
set -e

# Use directory of current script as the working directory
cd "\$( dirname "${BASH_SOURCE[0]}" )"
PROJECT_ROOT="\$(cd ../.. && pwd)"
PROJECT_JNI_ROOT="${PROJECT_ROOT}/bindings/jna"

# Configuration
export NDK_VERSION="${NDK_VERSION:-$(project.android_ndk_version)}"
export ANDROID_NDK_ROOT="${ANDROID_NDK_ROOT:-/tmp/${NDK_VERSION}}"
export MIN_SDK_VERSION=${MIN_SDK_VERSION:-$(project.android_min_sdk_version)}
export ANDROID_BUILD_DIR="${ANDROID_BUILD_DIR:-${PWD}/.build}"
export ANDROID_DEPENDENCIES_DIR="${ANDROID_DEPENDENCIES_DIR:-${PWD}/.deps}"
export BUILD_PREFIX="${BUILD_PREFIX:-/tmp/jni_build}"

export TRAVIS_TAG="${TRAVIS_TAG:-no}"
export TRAVIS_OS_NAME="${TRAVIS_OS_NAME:-}"
export BINDING_OPTS="${BINDING_OPTS:-}"

export CI_CONFIG_QUIET="${CI_CONFIG_QUIET:-yes}"
export CI_TIME="${CI_TIME:-}"
export CI_TRACE="${CI_TRACE:-no}"

# By default, dependencies will be cloned to /tmp/tmp-deps.
# If you have your own source tree for XXX, uncomment its
# XXX_ROOT configuration line below, and provide its absolute tree:
.for use where defined (use.repository)
#    export $(USE.PROJECT)_ROOT="<absolute_path_to_$(USE.PROJECT)_source_tree>"
.endfor

########################################################################
# Preparation
########################################################################
# Get access to android_build functions and variables
# Perform some sanity checks and calculate some variables.
source "${PROJECT_ROOT}/builds/android/android_build_helper.sh"

# Initialize our dependency _ROOT variables:
.    for use where defined (use.repository)
android_init_dependency_root "$(use.project)"     # Check or initialize $(USE.PROJECT)_ROOT
.    endfor

# Fetch required dependencies:
.    for use where defined (use.repository)
.        if defined (use.tarball)
[ ! -d "${$(USE.PROJECT)_ROOT}" ]   && android_download_library "$(USE.PROJECT)" "${$(USE.PROJECT)_ROOT}" "$(use.tarball)"
.        else
[ ! -d "${$(USE.PROJECT)_ROOT}" ]   && android_clone_library "$(USE.PROJECT)" "${$(USE.PROJECT)_ROOT}" "$(use.repository)" "$(use.release?)"
.        endif
.    endfor

android_download_ndk

case "$CI_TIME" in
    [Yy][Ee][Ss]|[Oo][Nn]|[Tt][Rr][Uu][Ee])
        CI_TIME="time -p " ;;
    [Nn][Oo]|[Oo][Ff][Ff]|[Ff][Aa][Ll][Ss][Ee])
        CI_TIME="" ;;
esac

case "$CI_TRACE" in
    [Nn][Oo]|[Oo][Ff][Ff]|[Ff][Aa][Ll][Ss][Ee])
        set +x ;;
    [Yy][Ee][Ss]|[Oo][Nn]|[Tt][Rr][Uu][Ee])
        set -x ;;
esac

CONFIG_OPTS=()
CONFIG_OPTS+=("CFLAGS=-I${BUILD_PREFIX}/include")
CONFIG_OPTS+=("CPPFLAGS=-I${BUILD_PREFIX}/include")
CONFIG_OPTS+=("CXXFLAGS=-I${BUILD_PREFIX}/include")
CONFIG_OPTS+=("LDFLAGS=-L${BUILD_PREFIX}/lib")
CONFIG_OPTS+=("PKG_CONFIG_PATH=${BUILD_PREFIX}/lib/pkgconfig")
CONFIG_OPTS+=("--prefix=${BUILD_PREFIX}")
CONFIG_OPTS+=("--with-docs=no")
[ "${CI_CONFIG_QUIET}" = "yes" ] && CONFIG_OPTS+=("--quiet")

GRADLEW_OPTS=()
GRADLEW_OPTS+=("-PbuildPrefix=$BUILD_PREFIX")
GRADLEW_OPTS+=("--info")

rm -rf /tmp/tmp-deps
mkdir -p /tmp/tmp-deps

########################################################################
# Clone and build native dependencies
########################################################################
[ -z "$CI_TIME" ] || echo "`date`: Starting build of dependencies (if any)..."

.for use where defined (use.repository)
######################
#  Build native '$(use.libname).so'
(
.   if count(use.add_config_opts) > 0
    # Custom additional options for $(use.project)
.       for use.add_config_opts as add_cfgopt
    CONFIG_OPTS+=("$(add_cfgopt)")
.       endfor

.   endif
    android_build_library "$(USE.PROJECT)" "${$(USE.PROJECT)_ROOT}"
)

.   if count (project->dependencies.class, class.project = use.project) > 0
# Build jni dependency
( cd ${$(USE.PROJECT)_ROOT}/bindings/jna && TERM=dumb $CI_TIME ./gradlew publishToMavenLocal ${GRADLEW_OPTS[@]} ${$(USE.PREFIX)_GRADLEW_OPTS} )
.   endif

.endfor
######################
# Build native '$(project.libname).so'
cd "${PROJECT_ROOT}"
[ -z "$CI_TIME" ] || echo "`date`: Starting build of currently tested project..."

(
.   if count(project.add_config_opts) > 0
    # Custom additional options for $(my.use.project)
.       for project.add_config_opts as add_cfgopt
    CONFIG_OPTS+=("$(add_cfgopt)")
.       endfor

.   endif
    android_build_library "$(PROJECT.LIBNAME)" "${PROJECT_ROOT}"
)

[ -z "$CI_TIME" ] || echo "`date`: Build completed without fatal errors!"

########################################################################
#  Build and check the jni android binding
########################################################################
cd "${PROJECT_JNI_ROOT}"
[ "${TRAVIS_TAG}" = "yes" ] && IS_RELEASE="-PisRelease"

if [ "$TRAVIS_OS_NAME" == "linux" ] && [ "$BINDING_OPTS" == "android" ]; then
    pushd $(project.prefix)/android
        $CI_TIME ./build.sh "arm"
        $CI_TIME ./build.sh "arm64"
        $CI_TIME ./build.sh "x86"
        $CI_TIME ./build.sh "x86_64"
    popd
fi

#   Build Jar for JVM
TERM=dumb $CI_TIME ./gradlew jvmJar ${GRADLEW_OPTS[@]} ${$(PROJECT.PREFIX)_GRADLEW_OPTS} $IS_RELEASE

#   Build Aar for Android
TERM=dumb $CI_TIME ./gradlew assemble ${GRADLEW_OPTS[@]} ${$(PROJECT.PREFIX)_GRADLEW_OPTS} $IS_RELEASE

#TERM=dumb $CI_TIME ./gradlew clean

$(project.GENERATED_WARNING_HEADER:)
.close
.chmod_x ("$(topdir)/ci_build.sh")
.if ! file.exists ("$(topdir)/gradle/wrapper/gradle-wrapper.jar")
.   echo "Note: Could not locate gradle wrapper for JNI Binding! See bindings/jni/README.md."
.endif
.endmacro

.macro generate_method (method)
.   if description <> ""
    /**
     * $(description:no,block)
     */
.   endif
    fun $(jni_name:)($(jni_method_signature:)): $(->return.jni_java_type:) {
.       if defined (method.return_self_p)
        self = nativeLib.$(class.c_name)_$(c_name)($(jni_shim_invocation_java:))
.       elsif ->return.type = "nothing"
        nativeLib.$(class.c_name)_$(c_name)($(jni_shim_invocation_java:))
.       elsif ->return.jni_is_class = 1
        return $(->return.type:pascal) (nativeLib.$(class.c_name)_$(c_name)($(jni_shim_invocation_java:)))
.       else
        return nativeLib.$(class.c_name)_$(c_name)($(jni_shim_invocation_java:))
.       endif
    }

.
.endmacro

.macro generate_class (class)
.   directory.create ("$(topdir)/$(project.prefix:c)/src/commonMain/kotlin/$(name_path)")
.   output "$(topdir)/$(project.prefix:c)/src/commonMain/kotlin/$(name_path)/$(my.class.name:pascal).kt"
/*
$(project.GENERATED_WARNING_HEADER:)
*/
package $(project.namespace)

import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer
.   for project.use
.       if count (project->dependencies.class, class.project = use.project) > 0
import org.zeromq.$(use.project).*
.       endif
.   endfor

class $(my.class.name:pascal) {

//    static {
//        Map<String, Boolean> libraries = new LinkedHashMap<>()
.       for project.use
//        libraries.put("$(use.linkname:c)", $(use.optional ?? 'true' ? 'false'))
.       endfor
//        libraries.put("$(project.linkname)", false)
//        libraries.put("$(project.linkname)jni", false)
//        ZmqNativeLoader.loadLibraries(libraries)
//    }

    private interface NativeLib : Library {
.   for constructor where okay
        fun $(class.c_name)_$(c_name)($(jni_shim_signature_java:)): $(->return.jni_shim_type:)
.   endfor
.   for destructor
        fun $(name:camel)(self: Pointer)
.   endfor
.   for method where okay
        fun $(class.c_name)_$(c_name)($(jni_shim_signature_java:)): $(->return.jni_shim_type:)
.   endfor
    }

    companion object {
        private val nativeLib: NativeLib =
            Native.load("$(project.linkname)", NativeLib::class.java)

.   for method where okay
.       if (singleton = 1 & !defined (method.return_self_p))
.           generate_method (method)
.       endif
.   endfor
    }
.   if my.class.static = 0

    var self: Pointer

.   endif
.   my.class.jni_void_new = 0
.   for constructor where okay
.       if description <> ""
    /**
     * $(description:no,block)
     */
.       endif
.       if index () = 1
    constructor($(jni_method_signature:)) {
        /*  TODO: if __$(name:camel) fails, self is null...  */
        self = nativeLib.$(class.c_name)_$(c_name)($(jni_shim_invocation_java:))
    }

    constructor(pointer: Pointer) {
        self = pointer
    }

.       else
//    public $(static) $(->return.jni_java_type:) $(jni_name:) ($(jni_method_signature:)) {
//        return new $(->return.type:pascal) (nativeLib.$(class.c_name)_$(c_name) ($(jni_shim_invocation_java:)))
//    }
//
.       endif
.   endfor
.   for destructor
.       if description <> ""
    /**
     * $(description:no,block)
     */
.       endif
//    @Override
//    public void close () {
//        nativeLib.$(class.c_name)_$(c_name)(self)
//        self = 0
//    }
//
.   endfor
.   for method where okay
.       if !(singleton = 1 & !defined (method.return_self_p))
.           generate_method (method)
.       endif
.   endfor
}
.endmacro

.macro generate_test_wrapper (class)
.   directory.create ("$(topdir)/$(project.prefix:c)/src/commonTest/kotlin/$(name_path)")
.   output "$(topdir)/$(project.prefix:c)/src/commonTest/kotlin/$(name_path)/$(my.class.name:pascal)Test.kt"
/*
$(project.GENERATED_WARNING_HEADER:)
*/
package $(project.namespace)

import kotlin.test.Test

class $(my.class.name:pascal)Test {

    @Test
    fun test() {
        $(my.class.name:pascal).test(false)
    }

}
.endmacro

    project.namespace ?= switches.namespace? "org.zeromq.$(project.prefix)"
    project.name_path ?= switches.name_path? "org/zeromq/$(project.prefix)"
    project.topdir = "bindings/jna"
    directory.create (topdir)

    for project.class
        resolve_class (class)
        if class.okay
            generate_class (class)
            generate_test_wrapper (class)
        endif
    endfor

    if count (project.class, okay = 1)
        generate_wrapper ()
    endif
endfunction
